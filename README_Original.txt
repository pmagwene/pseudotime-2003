August 2004
============

Author: Paul M. Magwene
Contact: paul.magwene@duke.edu

Changes
========
Aug '04
    * updated code to dictionary of dictionaries graph representation
    * included io.py and graph.py libraries for I/O operations and graph manipulation
    * added/updated doc strings
    * removed dependencies on kjbuckets and older libraries
    * deleted stale code
Dec '06
    * restored the missing rank_paths function in pathrecon
    * confirmed examples in README still work with recent builds of Python
    

Requirements
============
Python 2.3+
Numeric 23.0 


Cautions
========
There is very little error checking performed to insure that input data are correct.  Ill formed data may cause functions in this library to choke, or may be consumed silently (potentially outputting nonsense).  Beware that the input data are as expected!

Also, the algorithms implemented herein have not been highly optimized.  Performance on relatively large data sets with lots of indecesive vertices may be unacceptably slow.  I recommend checking compute times with reasonable subsets of your data before analyzing a large data set.


Usage
=====

Fire up the python interpreter and import the necessary modules:

Python 2.3.4 (#53, May 25 2004, 21:17:02) [MSC v.1200 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> import pathrecon, io, graph
>>> import Numeric as Num


The "jellyroll.txt" data set contains 2D points generated by sampling with noise from a generating function that represents the involute of a circle (see: http://mathworld.wolfram.com/CircleInvolute.html for more information about circle involutes).  This is the data shown in Fig. 2a of Magwene et al. 2003.

To load the jellyroll.txt data set and prepare it for analysis do the following:

>>> jelly = io.tableasrows("jellyroll.txt", autoconvert=True)
>>> jelly = Num.array(jelly)

To generate the minimum spanning tree (MST) and diameter path of Figs. 2b and 2c, do the following:

>>> mst, diampath, diampathlen = pathrecon.mst_and_diameterpath(jelly)

The "mst_and_diameterpath" function will calculate the Euclidean distances among all observations in the dataset.  Based on the distance matrix it will then calculate a minimum spanning tree and the diameter path of that minimum spanning tree.

The diameter path is expressed simply as a list of integer indices:

>>> diampath
[79, 39, 119, 78, 118, 77, 37, 117, 36, 116, ....]

The total length of the diameter path is:

>>> diampathlen
95.076581360819802

The minimum spanning tree is represented by a graph data structure based on a dictionary of dictionaries (see graph.py for more info). To get the edges of the MST do the following:

>>> graph.edges(mst)
Set([(16, 96), (8, 47), (49, 89), (45, 85), ... ]


The alpha factor synchronized gene expression data set described in the paper (Fig 3a) can be loaded as follows:

>>> alpha = io.tableasrows('alpha.txt', autoconvert=True, hasrownames=True)
>>> alpha = Num.transpose(Num.array(alpha))

[Note: we transposed the data because the 'alpha.txt' file lists the variables (genes) in rows, rather than the observations (time pts).]

Again, we can calculate the MST and diameter path:

>>> mst, diampath, diampathlen = pathrecon.mst_and_diameterpath(alpha)

To get the edges of the MST (Fig 3b) do:

>>> graph.edges(mst)
Set([(16, 17), (13, 15), (0, 1), (3, 4), (11, 12), (12, 13), (7, 8), (5, 6), (10
, 11), (6, 7), (9, 17), (4, 5), (14, 15), (15, 16), (7, 16), (1, 2), (2, 3)])

To calculate the PQ tree based on the MST (Fig 3C) do:

>>> pqtree = pathrecon.make_pqtree(mst)
>>> pqtree
([(15,), (13, 12, 11, 10), (14,)], [(16,), (17, 9)], [(7,), (8,), (0, 1, 2, 3, 4
, 5, 6)])

P-nodes are represented by lists, Q-nodes are represented by tuples. So for examples, the first element above:

[(16,), (17, 9)]

is a P-node, containing two Q-nodes.

[Note: remember, Python indexes from 0]

To calculate the permutations of the PQ tree do:

>>> pqperm = pathrecon.pqtree_perms(pqtree)

Note: depending on the PQ tree the number of permutations may be huge.  Consider your problem size and number of indecisive vertices before generating permutations.

For the PQ tree under consideration there are 576 paths consistent with the PQ tree. We can rank these paths by their length as follows:

>>> dist = pathrecon.distance_matrix(alpha)
>>> rpaths = pathrecon.rank_paths(pqperm, dist)

We can print out the top 10 ranked paths, and their lengths in the following manner:
>>> for i in range(10):
...   print i, rpaths.paths[i], rpaths.lengths[i]
...

[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 17, 16, 15, 14, 13, 12, 11, 10] 208.058844676
[0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 17, 9, 10, 11, 12, 13, 15, 14] 209.508319108
[0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 17, 9, 10, 11, 12, 13, 14, 15] 209.592225526
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 17, 16, 14, 15, 13, 12, 11, 10] 209.803703466
[0, 1, 2, 3, 4, 5, 6, 7, 8, 17, 9, 16, 15, 14, 13, 12, 11, 10] 210.330224454
[0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 17, 9, 15, 14, 13, 12, 11, 10] 210.927895415
[0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 9, 17, 15, 14, 13, 12, 11, 10] 210.931985601
[0, 1, 2, 3, 4, 5, 6, 8, 7, 16, 17, 9, 10, 11, 12, 13, 15, 14] 211.046266626
[0, 1, 2, 3, 4, 5, 6, 8, 7, 16, 17, 9, 10, 11, 12, 13, 14, 15] 211.130173044
[0, 1, 2, 3, 4, 5, 6, 8, 7, 9, 17, 16, 15, 14, 13, 12, 11, 10] 211.820448187

This is the data of Table 1 in Magwene et al. 2003.


